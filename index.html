<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì‚¼ê°í˜• ë¶„ë¥˜ ê²Œì„</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --card:#101624cc;
      --glass:rgba(255,255,255,0.08);
      --white:#f5f7ff;
      --accent:#4da3ff;
      --accent-2:#7ce7ff;
      --success:#5bd69f;
      --warn:#ffb84d;
      --danger:#ff5d6c;
      --shadow:0 20px 40px rgba(0,0,0,.35);
      --radius:22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Helvetica,Arial,sans-serif;
      color:var(--white);
      background: radial-gradient(1200px 800px at 20% 10%, #13203b 0%, #0a0d16 45%, #070a12 100%),
                  radial-gradient(1000px 600px at 90% 80%, #0e1c2e 0%, #0a0d16 50%, #070a12 100%);
      overflow:hidden;
    }
    .app{
      width:90vw; height:90vh; margin:5vh auto; position:relative;
      display:grid; grid-template-columns: 1.4fr 0.6fr; gap:24px;
      padding:24px; border-radius:28px; backdrop-filter: blur(12px);
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      box-shadow: var(--shadow);
      border:1px solid rgba(255,255,255,0.06);
    }
    header{
      position:absolute; top:10px; left:24px; right:24px; display:flex; justify-content:flex-start; align-items:center;
      pointer-events:none;
    }
    .title{font-weight:700; letter-spacing:0.3px; text-shadow:0 2px 20px rgba(0,0,0,.35)}

    /* left grid: 3x3 cards */
    .grid{
      display:grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap:18px;
      align-content:stretch; justify-items:stretch; height:100%;
    }
    .card{ position:relative; user-select:none; }
    .card-inner{
      position:absolute; inset:0; border-radius:var(--radius); overflow:hidden;
      transition: box-shadow .3s;
      box-shadow: var(--shadow); background: var(--card); border:1px solid rgba(255,255,255,.08);
    }
    /* reveal without flipping */
    .card .front, .card .back{ position:absolute; inset:0; transition:opacity .4s ease; padding:8px; }
    .card .back{ opacity:0 }
    .card.revealed .front{ opacity:0 }
    .card.revealed .back{ opacity:1 }

    .face{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      font-weight:800; font-size:56px;
      background: linear-gradient(145deg, rgba(255,255,255,0.07), rgba(255,255,255,0.02));
    }
    .front{ color:#e9efff }
    .back{ padding:8px; }
    .card.active .card-inner{ box-shadow: 0 30px 60px rgba(0,120,255,.45) }
    .triangle-wrap{ position:relative; width:100%; height:100%; border-radius:var(--radius);
      background: radial-gradient(600px 280px at 40% 10%, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
    }
    .triangle-wrap svg{ width:100%; height:100% }
    .label{ font-size:13px; fill:#dfe7ff; text-shadow:0 2px 6px rgba(0,0,0,.6) }

    /* right panel: bins */
    .side{ display:grid; grid-template-rows: 1fr auto; gap:12px; height:100%; }
    .bins{ display:grid; grid-template-columns: repeat(2, 1fr); grid-auto-rows: 1fr; gap:14px; }
    .bin{
      position:relative; border-radius:20px; padding:12px; background:var(--glass);
      border:1px solid rgba(255,255,255,.08); box-shadow: var(--shadow);
      display:flex; align-items:center; justify-content:center; text-align:center;
      font-weight:700; line-height:1.25; letter-spacing:.2px; padding-inline:16px;
    }
    .bin .badge{ position:absolute; top:10px; left:10px; font-size:11px; opacity:.8 }
    .bin.filled{ filter: blur(1px) saturate(.8) brightness(.88); }
    .bin.accepting{ outline:2px dashed var(--accent-2); outline-offset: -6px }

    .footer{ display:flex; justify-content:space-between; align-items:center; }
    .hint{ font-size:12px; opacity:.75 }

    /* overlays */
    .start-overlay, .blocker, .mission{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background: linear-gradient(180deg, rgba(10,13,22,.75), rgba(10,13,22,.75));
      z-index:30; backdrop-filter: blur(6px);
    }
    .start-card{
      width:min(540px, 90%); padding:28px; border-radius:26px; text-align:center;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
      border:1px solid rgba(255,255,255,.12); box-shadow: var(--shadow);
    }
    .start-card h1{ margin:0 0 12px; font-size:32px }
    .start-card p{ margin:0 0 20px; opacity:.85 }

    .toast{
      position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
      padding:10px 14px; border-radius:999px; background:#182238; border:1px solid rgba(255,255,255,.08);
      box-shadow: var(--shadow); font-size:14px; opacity:0; transition:opacity .25s, transform .25s;
      z-index:40;
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(-6px) }

    /* floating discard button (bottom-right) */
    #discardBtn{
      position:absolute; right:22px; bottom:18px; z-index:35;
      appearance:none; border:0; padding:14px 18px; border-radius:18px; cursor:pointer; font-weight:600;
      color:#0a0d16; background:linear-gradient(180deg, #ffdfe3, #ffb3bd);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.9), 0 8px 18px rgba(0,0,0,.35);
    }
    #discardBtn[disabled]{ filter:grayscale(.4) brightness(.85); cursor:not-allowed }

    @media (max-width: 1100px){
      .app{ grid-template-columns: 1fr; overflow:auto; height:auto; }
      body{ overflow:auto }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="title">ğŸ“ ì‚¼ê°í˜• ë¶„ë¥˜ ë“œë˜ê·¸&ë“œë¡­</div>
    </header>

    <section class="grid" id="cardGrid" aria-label="ì¹´ë“œ 9ì¥"></section>

    <aside class="side">
      <div class="bins" id="bins">
        <div class="bin" data-key="acute"   aria-label="ì˜ˆê°ì‚¼ê°í˜•"     tabindex="0"><span class="badge">ê°</span>ì˜ˆê°ì‚¼ê°í˜•</div>
        <div class="bin" data-key="right"   aria-label="ì§ê°ì‚¼ê°í˜•"     tabindex="0"><span class="badge">ê°</span>ì§ê°ì‚¼ê°í˜•</div>
        <div class="bin" data-key="obtuse"  aria-label="ë‘”ê°ì‚¼ê°í˜•"     tabindex="0"><span class="badge">ê°</span>ë‘”ê°ì‚¼ê°í˜•</div>
        <div class="bin" data-key="scalene" aria-label="ì„¸ ë³€ ëª¨ë‘ ë‹¤ë¦„" tabindex="0"><span class="badge">ë³€</span>ì„¸ ë³€ì˜ ê¸¸ì´ê°€ ëª¨ë‘ ë‹¤ë¥¸ ì‚¼ê°í˜•</div>
        <div class="bin" data-key="isosceles" aria-label="ì´ë“±ë³€"      tabindex="0"><span class="badge">ë³€</span>ì´ë“±ë³€ì‚¼ê°í˜•</div>
        <div class="bin" data-key="equilateral" aria-label="ì •ì‚¼ê°í˜•" tabindex="0"><span class="badge">ë³€</span>ì •ì‚¼ê°í˜•</div>
      </div>
      <div class="footer">
        <div class="hint">ì¹´ë“œë¥¼ ëˆŒëŸ¬ ë’¤ì§‘ê³ , í•´ë‹¹í•˜ëŠ” ì¹¸ìœ¼ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”. í—·ê°ˆë¦¬ë©´ <b>ë²„ë¦¬ê¸°</b>ë¡œ ë„˜ê¸¸ ìˆ˜ ìˆì–´ìš”.</div>
      </div>
    </aside>

    <div class="start-overlay" id="start">
      <div class="start-card">
        <h1>ì‹œì‘í• ê¹Œìš”?</h1>
        <p>ì¹´ë“œ 9ì¥ì„ ë’¤ì§‘ì–´ ì‚¼ê°í˜•ì˜ <b>ê°</b>ê³¼ <b>ë³€</b> ì†ì„±ì— ë§ê²Œ ë¶„ë¥˜í•˜ì„¸ìš”.</p>
        <button id="startBtn" class="secondary" style="min-width:140px">ì‹œì‘</button>
      </div>
    </div>

    <div class="blocker" id="blocker" style="display:none">
      <div class="start-card" style="padding:16px 22px">ë‹¤ìŒ ì‚¼ê°í˜•ì„ ì¤€ë¹„ì¤‘â€¦ (2ì´ˆ)</div>
    </div>

    <div class="mission" id="mission" style="display:none">
      <div class="start-card">
        <h1 style="font-size:44px">ğŸ‰ ë¯¸ì…˜ ì™„ë£Œ!</h1>
        <p style="font-size:18px">6ê°€ì§€ ì†ì„±ì„ ëª¨ë‘ ì±„ì› ìŠµë‹ˆë‹¤.</p>
      </div>
    </div>

    <button id="discardBtn" class="danger" disabled>ë²„ë¦¬ê¸°</button>

    <div class="toast" id="toast">ì•ˆë‚´</div>
  </div>

<script>
(function(){
  const EPS = 0.02; // cm equality tolerance
  const RESET_AFTER = 3; // âœ… 3ì¥ì˜ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ìƒˆ ë±ìœ¼ë¡œ êµì²´
  const toRad = d=> d*Math.PI/180;
  const toDeg = r=> r*180/Math.PI;
  const clamp = (x, a, b)=> Math.max(a, Math.min(b, x));
  const rnd = (min,max)=> Math.random()*(max-min)+min;
  const rndInt = (min,max)=> Math.floor(rnd(min,max+1));
  const fmtLen = x=> Math.round(x) + " cm"; // 1cm ë‹¨ìœ„ í‘œê¸°
  const fmtDeg = x=> (Math.abs(x-90) < 0.5 ? 90 : Math.round(x)) + "Â°"; // 1Â° ë‹¨ìœ„ í‘œê¸°

  // ---- Triangle generators ----
  function fromAngles(aA, aB, aC, maxSide=6){
    const sA = Math.sin(toRad(aA)), sB = Math.sin(toRad(aB)), sC = Math.sin(toRad(aC));
    const m = rnd(3.5, maxSide); // choose target max side â‰¤ 6 cm
    const k = m / Math.max(sA,sB,sC);
    const A = k*sA, B=k*sB, C=k*sC; // sides opposite A,B,C
    return [A,B,C];
  }
  function anglesFromSides(a,b,c){
    const A = toDeg(Math.acos(clamp((b*b + c*c - a*a)/(2*b*c), -1, 1)));
    const B = toDeg(Math.acos(clamp((a*a + c*c - b*b)/(2*a*c), -1, 1)));
    const C = 180 - A - B;
    return [A,B,C];
  }
  function classifyAngle(As){
    const maxA = Math.max(...As);
    if (Math.abs(maxA - 90) < 0.1) return 'right';
    return maxA < 90 ? 'acute' : 'obtuse';
  }
  function classifySides(a,b,c){
    const eq = (x,y)=> Math.abs(x-y) < EPS;
    if (eq(a,b) && eq(b,c)) return 'equilateral';
    if (eq(a,b) || eq(b,c) || eq(a,c)) return 'isosceles';
    return 'scalene';
  }

  function genEquilateral(){
    const s = rndInt(3, 6); // ì •ìˆ˜ cm ì„ íƒ
    const sides=[s,s,s];
    const ang=[60,60,60];
    return {sides, ang, angleType:'acute', sideType:'equilateral'};
  }
  function genIsoAcute(){
    const theta = rnd(30, 60); // vertex angle
    const fac = Math.sqrt(2*(1 - Math.cos(toRad(theta)))); // base / a
    const aMax = 6 / fac; // ensure base â‰¤ 6
    const a = rnd(3.0, Math.min(6.0, aMax)); // equal sides
    const b = a * fac; // base
    const [A,B,C] = anglesFromSides(b,a,a);
    return {sides:[b,a,a], ang:[A,B,C], angleType:'acute', sideType:'isosceles'};
  }
  function genIsoRight(){
    const a = rnd(2.5, 4.2); // legs; hyp â‰¤ 6
    const b = a; const c = a*Math.SQRT2; // hypotenuse
    return {sides:[c,a,b], ang:[90,45,45], angleType:'right', sideType:'isosceles'};
  }
  function genIsoObtuse(){
    const theta = rnd(111, 140);
    const fac = Math.sqrt(2*(1 - Math.cos(toRad(theta)))); // base / a
    const aMax = 6 / fac; // ensure base â‰¤ 6
    const a = rnd(2.6, Math.min(4.0, aMax));
    const b = a * fac;
    const [A,B,C] = anglesFromSides(b,a,a);
    return {sides:[b,a,a], ang:[A,B,C], angleType:'obtuse', sideType:'isosceles'};
  }
  function genRightScalene(){
    const s = rnd(0.8, 1.2); // scale 3-4-5, hyp 5s â‰¤ 6
    let a = 3*s, b=4*s, c=5*s; // c is hyp
    const ang=[90, Math.atan2(3,4)*180/Math.PI, Math.atan2(4,3)*180/Math.PI];
    return {sides:[c,a,b], ang:[90, ang[1], ang[2]], angleType:'right', sideType:'scalene'};
  }
  function genAcuteScalene(){
    let A, B, C;
    for(let t=0;t<100;t++){
      A = rnd(30, 60);
      B = rnd(30, 60);
      C = 180 - A - B;
      if (C>30 && C<60) break;
    }
    const sides = fromAngles(A,B,C,6);
    if (new Set(sides.map(x=>x.toFixed(2))).size < 3){
      A += 2; C -= 2;
      sides.splice(0,3, ...fromAngles(A,B,C,6));
    }
    return {sides, ang:[A,B,C], angleType:'acute', sideType:'scalene'};
  }
  function genObtuseScalene(){
    const A = rnd(111, 140);
    let B = rnd(25, 58);
    let C = 180 - A - B;
    if (C < 20 || C >= 70){ B = 180 - A - 40; C = 40; }
    const sides = fromAngles(A,B,C,6);
    return {sides, ang:[A,B,C], angleType:'obtuse', sideType:'scalene'};
  }

  const TYPE_DEF = [
    {id:1, angle:'acute',  side:'scalene',     gen: genAcuteScalene},
    {id:2, angle:'acute',  side:'isosceles',   gen: genIsoAcute},
    {id:3, angle:'acute',  side:'equilateral', gen: genEquilateral},
    {id:4, angle:'right',  side:'scalene',     gen: genRightScalene},
    {id:5, angle:'right',  side:'isosceles',   gen: genIsoRight},
    {id:6, angle:'obtuse', side:'scalene',     gen: genObtuseScalene},
    {id:7, angle:'obtuse', side:'isosceles',   gen: genIsoObtuse}
  ];

  function prepareTypeBag(){
    // 3 types duplicated (2 each = 6) + 3 single = 9 total
    const shuffled = [...TYPE_DEF].sort(()=>Math.random()-0.5);
    const dup = shuffled.slice(0,3), single = shuffled.slice(3,6);
    const bag = [];
    dup.forEach(t=> bag.push(t,t));
    single.forEach(t=> bag.push(t));
    return bag.sort(()=>Math.random()-0.5);
  }

  // ---- Geometry â†’ Coordinates (SVG) ----
  function coordsFromSides(a,b,c){
    const A = (b*b + c*c - a*a)/(2*c); // x of point C
    const xC = A; const y2 = b*b - A*A; const yC = Math.sqrt(Math.max(0,y2));
    return [{x:0,y:0},{x:c,y:0},{x:xC,y:yC}]; // B(0,0), A(c,0), C(xC,yC)
  }
  function buildTriangleSVG(sides){
    const sorted = [...sides].map((v,i)=>({v,i})).sort((p,q)=>q.v - p.v);
    const baseIndex = sorted[0].i;
    let a,b,c;
    if (baseIndex===0){ a=sides[0]; b=sides[1]; c=sides[2]; }
    else if (baseIndex===1){ a=sides[1]; b=sides[2]; c=sides[0]; }
    else { a=sides[2]; b=sides[0]; c=sides[1]; }

    const A = toDeg(Math.acos(clamp((b*b + c*c - a*a)/(2*b*c), -1, 1)));
    const B = toDeg(Math.acos(clamp((a*a + c*c - b*b)/(2*a*c), -1, 1)));
    const C = 180 - A - B;

    const pts = coordsFromSides(a,b,c);

    // --- layout: ë„‰ë„‰í•œ ì—¬ë°± + ë‚´ë¶€ ë¼ë²¨ ë°°ì¹˜ë¡œ ì˜ë¦¼ ë°©ì§€ ---
    const padX = 36, padY = 32;
    const targetW = 340, targetH = 260;
    const pxPerCm = Math.min( (targetW-2*padX)/c, (targetH-2*padY)/(Math.max(pts[2].y, 1e-6)) );

    const P = pts.map(p=>({x:padX + p.x*pxPerCm, y:targetH - (padY + p.y*pxPerCm)}));
    const path = `M ${P[0].x},${P[0].y} L ${P[1].x},${P[1].y} L ${P[2].x},${P[2].y} Z`;

    const mid = (p,q)=>({x:(p.x+q.x)/2, y:(p.y+q.y)/2});
    const mAB = mid(P[0],P[1]), mBC = mid(P[0],P[2]), mCA = mid(P[1],P[2]);

    // ê°ë„ ë¼ë²¨ì€ ê¼­ì§“ì ì—ì„œ ë¬´ê²Œì¤‘ì‹¬ ë°©í–¥ìœ¼ë¡œ ì•ˆìª½ ë°°ì¹˜
    const centroid = {x:(P[0].x+P[1].x+P[2].x)/3, y:(P[0].y+P[1].y+P[2].y)/3};
    const toward = (v)=>({x:v.x + (centroid.x - v.x)*0.18, y:v.y + (centroid.y - v.y)*0.18});
    const lblA = toward(P[0]);
    const lblB = toward(P[1]);
    const lblC = toward(P[2]);

    const svg = `
      <svg viewBox="0 0 ${targetW} ${targetH}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="3" flood-color="${getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}" flood-opacity="0.55" />
          </filter>
        </defs>
        <rect x="0" y="0" width="100%" height="100%" rx="18" ry="18" fill="url(#bggrad)" opacity="0"/>
        <g filter="url(#glow)">
          <path d="${path}" fill="rgba(125,188,255,0.10)" stroke="#b9d6ff" stroke-width="2.4" />
        </g>
        <g class="labels">
          <text class="label" x="${mAB.x}" y="${mAB.y-4}" text-anchor="middle">${fmtLen(c)}</text>
          <text class="label" x="${mBC.x}" y="${mBC.y-4}" text-anchor="middle">${fmtLen(a)}</text>
          <text class="label" x="${mCA.x}" y="${mCA.y-4}" text-anchor="middle">${fmtLen(b)}</text>
          <text class="label" x="${lblA.x}" y="${lblA.y}">A ${fmtDeg(A)}</text>
          <text class="label" x="${lblB.x}" y="${lblB.y}">B ${fmtDeg(B)}</text>
          <text class="label" x="${lblC.x}" y="${lblC.y}">C ${fmtDeg(C)}</text>
        </g>
      </svg>`;
    return {svg, angles:[A,B,C]};
  }

  // ---- Build deck ----
  let deck = [];
  let usedThisDeck = 0; // picks (ì •ë‹µ/ë²„ë¦¬ê¸° í¬í•¨) ì¹´ìš´íŠ¸
  let activeIndex = null; // í˜„ì¬ í™œì„± ì¹´ë“œ idx
  const binsState = { acute:false, right:false, obtuse:false, scalene:false, isosceles:false, equilateral:false };

  function makeTriangle(tdef){
    let tri;
    for(let tries=0; tries<60; tries++){
      const g = tdef.gen();
      const [A,B,C] = anglesFromSides(g.sides[0], g.sides[1], g.sides[2]);
      let angleType = classifyAngle([A,B,C]);
      // ë¹„ì§ê°ì€ 70~110 ì œì™¸
      if (tdef.angle==='right'){
        if (Math.abs(Math.max(A,B,C)-90) > 0.3) continue;
      } else {
        const nonRight = [A,B,C].filter(x=> Math.abs(x-90) >= 0.5);
        if (nonRight.some(x=> x>=70 && x<=110)) continue;
      }
      let sideType = classifySides(...g.sides);

      // ğŸ”’ ì •ì‚¼ê°í˜• ê°•ì œ ê·œì¹™: í‘œì‹œ ê¸¸ì´ê°€ ëª¨ë‘ ê°™ì€ ê²½ìš°, ì •ì‚¼ê°í˜•ìœ¼ë¡œ ê³ ì •
      const disp = g.sides.map(x=> Math.round(x));
      if (disp[0]===disp[1] && disp[1]===disp[2]){
        const L = Math.max(2, Math.min(6, disp[0]));
        const sides=[L,L,L];
        const ang=[60,60,60];
        const {svg} = buildTriangleSVG(sides);
        tri = {sides, angles:ang, angleType:'acute', sideType:'equilateral', svg};
        break;
      }

      if (Math.max(...g.sides) > 6 + 1e-6) continue; // longest side â‰¤ 6
      const {svg, angles} = buildTriangleSVG(g.sides);
      tri = {sides:g.sides, angles, angleType, sideType, svg};
      break;
    }
    if(!tri){
      const fallback = genEquilateral();
      const {svg} = buildTriangleSVG(fallback.sides);
      tri = {sides:fallback.sides, angles:[60,60,60], angleType:'acute', sideType:'equilateral', svg};
    }
    return tri;
  }

  function buildDeck(){
    deck = [];
    usedThisDeck = 0; // ìƒˆ ë± ì‹œì‘ ì‹œ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
    const bag = prepareTypeBag();
    for(let i=0;i<9;i++){
      const tdef = bag[i % bag.length];
      const tri = makeTriangle(tdef);
      deck.push({ id:i, num:i+1, ...tri, used:false });
    }
  }

  // ---- UI rendering ----
  const grid = document.getElementById('cardGrid');
  const start = document.getElementById('start');
  const startBtn = document.getElementById('startBtn');
  const discardBtn = document.getElementById('discardBtn');
  const blocker = document.getElementById('blocker');
  const mission = document.getElementById('mission');
  const toastEl = document.getElementById('toast');

  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=> toastEl.classList.remove('show'), 1200);
  }

  function renderGrid(){
    grid.innerHTML = '';
    deck.forEach((card, idx)=>{
      const el = document.createElement('div');
      el.className = 'card';
      el.dataset.idx = idx;
      el.innerHTML = `
        <div class="card-inner">
          <div class="face front">${card.num}</div>
          <div class="face back">
            <div class="triangle-wrap">${card.svg}</div>
          </div>
        </div>`;
      el.addEventListener('click', ()=> onCardClick(el, idx));
      grid.appendChild(el);
    });
  }

  function onCardClick(el, idx){
    if (blocker.style.display==='flex' || mission.style.display==='flex') return; // during delay or finished
    const card = deck[idx];
    if (card.used) return;
    if (activeIndex !== null && activeIndex!==idx) return; // only one at a time
    activeIndex = idx;
    el.classList.add('revealed','active');
    el.setAttribute('draggable','true');
    el.addEventListener('dragstart', (ev)=>{
      ev.dataTransfer.setData('text/plain', String(idx));
      ev.dataTransfer.effectAllowed = 'move';
    });
    discardBtn.disabled = false;
  }

  function triangleProps(card){
    return [card.angleType, card.sideType];
  }

  function showMissionOverlay(){
    // ëª¨ë“  ìƒí˜¸ì‘ìš© ì°¨ë‹¨
    discardBtn.disabled = true;
    mission.style.display='flex';
  }

  function endTurn(idx){
    const el = grid.querySelector(`.card[data-idx="${idx}"]`);
    if (el){ el.style.visibility='hidden'; el.style.pointerEvents='none'; }
    deck[idx].used = true; usedThisDeck++;
    activeIndex = null;
    discardBtn.disabled = true;
    blocker.style.display='flex';
    setTimeout(()=>{
      blocker.style.display='none';
      const allUsed = deck.every(c=> c.used);
      const allBins = Object.values(binsState).every(v=> v);
      if (allBins){
        showMissionOverlay();
        return;
      }
      if (usedThisDeck >= RESET_AFTER){
        buildDeck();
        renderGrid();
        showToast('ìƒˆ ì¹´ë“œ 9ì¥ì„ ë°°ì¹˜í–ˆì–´ìš”.');
        return;
      }
      if (allUsed){
        showToast('ì¹´ë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆì–´ìš”!');
      }
    }, 2000);
  }

  // ---- Drag & Drop bins ----
  document.querySelectorAll('.bin').forEach(bin=>{
    bin.addEventListener('dragover', (ev)=>{
      if (activeIndex===null || mission.style.display==='flex') return;
      ev.preventDefault();
      bin.classList.add('accepting');
    });
    bin.addEventListener('dragleave', ()=> bin.classList.remove('accepting'));
    bin.addEventListener('drop', (ev)=>{
      ev.preventDefault();
      bin.classList.remove('accepting');
      if (activeIndex===null || mission.style.display==='flex') return;
      const key = bin.dataset.key;
      const card = deck[activeIndex];
      if (binsState[key]){ showToast('ì´ë¯¸ ì±„ìš´ ì¹¸ì´ì—ìš”. ë‹¤ë¥¸ ì¹¸ì„ ì‹œë„í•˜ê±°ë‚˜ ë²„ë¦¬ê¸°ë¥¼ ëˆ„ë¥´ì„¸ìš”.'); return; }
      const props = triangleProps(card);
      if (props.includes(key)){
        binsState[key] = true;
        bin.classList.add('filled');
        showToast('ì •ë‹µ! í•´ë‹¹ ì†ì„±ì„ ì±„ì› ì–´ìš”.');
        endTurn(activeIndex);
      } else {
        showToast('ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”. ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ë²„ë¦¬ê¸°ë¥¼ ëˆ„ë¥´ì„¸ìš”.');
      }
    });
  });

  // Discard button (í•­ìƒ í‘œì‹œ)
  document.getElementById('discardBtn').addEventListener('click', ()=>{
    if (activeIndex===null || mission.style.display==='flex') return;
    showToast('ë²„ë ¸ì–´ìš”. ë‹¤ìŒ ì¹´ë“œë¡œâ€¦');
    endTurn(activeIndex);
  });

  // Start
  document.getElementById('startBtn').addEventListener('click', ()=>{
    document.getElementById('start').style.display='none';
    buildDeck();
    renderGrid();
  });

  // ---------------- TESTS (console) ----------------
  (function runTests(){
    try{
      // ê¸°ë³¸ ìƒì„± ê²€ì¦
      buildDeck();
      console.assert(deck.length===9, 'ë± í¬ê¸°ëŠ” 9ì—¬ì•¼ í•©ë‹ˆë‹¤.');
      const maxSideOk = deck.every(c=> Math.max(...c.sides) <= 6 + 1e-6);
      console.assert(maxSideOk, 'ëª¨ë“  ì‚¼ê°í˜•ì˜ ìµœëŒ€ ë³€ ê¸¸ì´ëŠ” 6cm ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');

      // ì •ì‚¼ê°í˜• ê° 60Â° ë³´ì¥
      const eq = genEquilateral();
      const eqAngles = anglesFromSides(...eq.sides).map(x=>Math.round(x));
      console.assert(eqAngles[0]===60 && eqAngles[1]===60 && eqAngles[2]===60, 'ì •ì‚¼ê°í˜• ê°ì€ 60Â°');

      // ì§ê° 3-4-5
      const angs = anglesFromSides(3,4,5).map(x=>Math.round(x));
      console.assert(angs.includes(90), '3-4-5ëŠ” ì§ê°');

      // ë¦¬ì…‹ ê¸°ì¤€ 3ì¥ í™•ì¸
      console.assert(RESET_AFTER===3, 'ë± ë¦¬ì…‹ ê¸°ì¤€ì€ 3ì¥ì´ì–´ì•¼ í•©ë‹ˆë‹¤.');

      console.log('%cí…ŒìŠ¤íŠ¸ í†µê³¼','background:#16a34a;color:white;padding:2px 6px;border-radius:6px');
    }catch(e){ console.error('í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨:', e); }
  })();

})();
</script>
</body>
</html>
